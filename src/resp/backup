
// pub struct RequestParserV1;

// impl RespRequest for RequestParserV1 {
//     fn parse(input: Vec<u8>) -> anyhow::Result<Vec<RespData>> {
//         if input.len() == 0 {
//             return Err(anyhow::anyhow!("Input length is zero"));
//         }

//         let input_str = String::from_utf8(input)?;
//         let mut iter = input_str.chars();
//         let type_flag = iter.nth(0).unwrap();
//         let data_type = DataType::try_from(type_flag)?;

//         match data_type {
//             DataType::Array => (),
//             _ => {
//                 return Err(anyhow::anyhow!(
//                     "Input must be protocol array but got: `{0:?}`",
//                     data_type
//                 ))
//             }
//         }

//         let (type_content, data_content) = input_str.split_once("\r\n").unwrap();

//         // TODO: take care when length > 9
//         let length_part = type_content.split_at(1).1.parse::<u32>()?;

//         let arr_len = match type_content.chars().nth(1) {
//             Some(length_str) => u32::try_from(length_str)?,
//             None => return Err(anyhow::anyhow!("Cannot parse input array length")),
//         };

//         let parts: Vec<&str> = data_content
//             .trim_end_matches(char::from(0))
//             .split("\r\n")
//             .collect();

//         let mut res: Vec<RespData> = Vec::with_capacity(usize::try_from(arr_len)?);
//         let mut parts_iter = parts.iter();
//         // Generate pairs
//         for _ in 1..arr_len {
//             let type_part = parts_iter.next().unwrap();
//             println!("t {0}", type_part);
//             let value_part = parts_iter.next().unwrap();
//             println!("v {0}", value_part);

//             let type_flag = type_part.to_string().chars().nth(0).unwrap();
//             let data_type = DataType::try_from(type_flag)?;

//             let data = match data_type {
//                 DataType::BulkString => RespData::BulkString(value_part.to_string()),
//                 _ => return Err(anyhow!("Unhandled data parse: {0:?}", data_type)),
//             };

//             res.push(data)
//         }

//         println!(
//             "len: {1}, parts: {0:?}, res: {2:?}",
//             parts, length_part, res
//         );

//         Ok(res)
//     }
// }


// impl TryFrom<String> for RespBulkString {
//     type Error = anyhow::Error;

//     fn try_from(value: String) -> anyhow::Result<Self> {
//         if !value.starts_with("$") {
//             return Err(anyhow::anyhow!("Invalid bulk string: `{0}`", value));
//         }

//         let schema_regex = BulkStringValidator::get_schema();

//         return match schema_regex.is_match(&value) {
//             true => {
//                 println!("Can parse");

//                 Ok(Self(String::from("")))
//             }
//             _ => Err(anyhow::anyhow!("Cannot parse")),
//         };
//     }
// }
